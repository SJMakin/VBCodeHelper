<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AvoidMicrosoftVisualBasicNamespaceAnalyzerDescription" xml:space="preserve">
    <value>Calls to the Microsoft.VisualBasic namespace should be avoided whereever possible.</value>
    <comment>An optional longer localizable description of the diagnostic.</comment>
  </data>
  <data name="AvoidMicrosoftVisualBasicNamespaceAnalyzerMessageFormat" xml:space="preserve">
    <value>'{0}' is in the Microsoft.VisualBasic namespace.  Please try and replace with a C# compatible method or type.</value>
    <comment>The format-able message the diagnostic displays.</comment>
  </data>
  <data name="AvoidMicrosoftVisualBasicNamespaceAnalyzerTitle" xml:space="preserve">
    <value>Avoid Microsoft.VisualBasic namespace</value>
    <comment>The title of the diagnostic.</comment>
  </data>
  <data name="CommentFormatAnalyzerDescription" xml:space="preserve">
    <value>Comments must be formatted for readability</value>
    <comment>An optional longer localizable description of the diagnostic.</comment>
  </data>
  <data name="CommentFormatAnalyzerMessageFormat" xml:space="preserve">
    <value>Comment is not formatted correctly: {0}</value>
    <comment>The format-able message the diagnostic displays.</comment>
  </data>
  <data name="CommentFormatRuleAnalyzerTitle" xml:space="preserve">
    <value>Format comment</value>
    <comment>The title of the diagnostic.</comment>
  </data>
  <data name="ConvertToSingleLineIfRuleAnalyzerDescription" xml:space="preserve">
    <value>Where possible use single line if statements as they are easier to read.</value>
    <comment>An optional longer localizable description of the diagnostic.</comment>
  </data>
  <data name="ConvertToSingleLineIfRuleAnalyzerMessageFormat" xml:space="preserve">
    <value>This can be conerted to a single line if.</value>
    <comment>The format-able message the diagnostic displays.</comment>
  </data>
  <data name="ConvertToSingleLineIfRuleAnalyzerTitle" xml:space="preserve">
    <value>Convert to a single line If</value>
    <comment>The title of the diagnostic.</comment>
  </data>
  <data name="HungarianNotationAnalyzerDescription" xml:space="preserve">
    <value>vUsing adjHungarian nnotation vmakes nreading ncode adjdifficult.</value>
    <comment>An optional longer localizable description of the diagnostic.</comment>
  </data>
  <data name="HungarianNotationAnalyzerMessageFormat" xml:space="preserve">
    <value>Remove the hungarian notation.</value>
    <comment>The format-able message the diagnostic displays.</comment>
  </data>
  <data name="HungarianNotationAnalyzerTitle" xml:space="preserve">
    <value>Hungarian Notation</value>
    <comment>The title of the diagnostic.</comment>
  </data>
  <data name="MethodCallMustHaveParenthesesAnalyzerDescription" xml:space="preserve">
    <value>Parentheses on method calls make them easily destingishable and improves readability of the code.</value>
    <comment>An optional longer localizable description of the diagnostic.</comment>
  </data>
  <data name="MethodCallMustHaveParenthesesAnalyzerMessageFormat" xml:space="preserve">
    <value>Method call lacks parentheses</value>
    <comment>The format-able message the diagnostic displays.</comment>
  </data>
  <data name="MethodCallMustHaveParenthesesRuleAnalyzerTitle" xml:space="preserve">
    <value>Method call should have parentheses</value>
    <comment>The title of the diagnostic.</comment>
  </data>
  <data name="ReplaceEmptyStringWithStringDotEmptyAnalyzerDescription" xml:space="preserve">
    <value>Use String.Empty as it is more readable</value>
    <comment>An optional longer localizable description of the diagnostic.</comment>
  </data>
  <data name="ReplaceEmptyStringWithStringDotEmptyAnalyzerMessageFormat" xml:space="preserve">
    <value>Replace with String.Empty</value>
    <comment>The format-able message the diagnostic displays.</comment>
  </data>
  <data name="ReplaceEmptyStringWithStringDotEmptyAnalyzerTitle" xml:space="preserve">
    <value>Use String.Empty</value>
    <comment>The title of the diagnostic.</comment>
  </data>
  <data name="SingleLineIfStatementParenthesesAnalyzerDescription" xml:space="preserve">
    <value>Parentheses on complex single line if statements make them easily destingishable and improves readability of the code.</value>
    <comment>An optional longer localizable description of the diagnostic.</comment>
  </data>
  <data name="SingleLineIfStatementParenthesesAnalyzerMessageFormat" xml:space="preserve">
    <value>Single line if is missing parentheses</value>
    <comment>The format-able message the diagnostic displays.</comment>
  </data>
  <data name="SingleLineIfStatementParenthesesAnalyzerTitle" xml:space="preserve">
    <value>Missing parantheses in line line if</value>
    <comment>The title of the diagnostic.</comment>
  </data>
  <data name="StringEqualsRuleAnalyzerDescription" xml:space="preserve">
    <value>Use the String.Equals shared member to compare string.  The method offers overloads to handle casing and culture-aware comparison, and when specified ensures that the string comparison will not change with Option Compare.</value>
    <comment>An optional longer localizable description of the diagnostic.</comment>
  </data>
  <data name="StringEqualsRuleAnalyzerMessageFormat" xml:space="preserve">
    <value>Use String.Equals to compare strings. </value>
    <comment>The format-able message the diagnostic displays.</comment>
  </data>
  <data name="StringEqualsRuleAnalyzerTitle" xml:space="preserve">
    <value>Compare strings with String.Equals</value>
    <comment>The title of the diagnostic.</comment>
  </data>
  <data name="UntidyGuardClauseRuleAnalyzerDescription" xml:space="preserve">
    <value>Single line guard clauses are easier to read.</value>
    <comment>An optional longer localizable description of the diagnostic.</comment>
  </data>
  <data name="UntidyGuardClauseRuleAnalyzerMessageFormat" xml:space="preserve">
    <value>This can be converted to a single line guard clause</value>
    <comment>The format-able message the diagnostic displays.</comment>
  </data>
  <data name="UntidyGuardClauseRuleAnalyzerTitle" xml:space="preserve">
    <value>Untidy guard clause</value>
    <comment>The title of the diagnostic.</comment>
  </data>
  <data name="VariableDeclarationAnalyzerDescription" xml:space="preserve">
    <value>Ensure value types are not initialised to their default and reference types are assigned a value.</value>
    <comment>An optional longer localizable description of the diagnostic.</comment>
  </data>
  <data name="VariableDeclarationAnalyzerMessageFormat" xml:space="preserve">
    <value>Variable declaration can be improved</value>
    <comment>The format-able message the diagnostic displays.</comment>
  </data>
  <data name="VariableDeclarationRuleAnalyzerTitle" xml:space="preserve">
    <value>Variable declaration</value>
    <comment>The title of the diagnostic.</comment>
  </data>
</root>